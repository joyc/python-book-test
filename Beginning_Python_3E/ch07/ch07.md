
- 多态：可对不同类型的对象执行相同的操作，而这些操作就像“被施了魔法”一样能够正常运行。
- 封装：对外部隐藏有关对象工作原理的细节。
- 继承：可基于通用类创建出专用类。

- 多态也算鸭子类型。
- 封装不同于多态。多态让你无需知道对象所属的类（对象的类型）就能调用其方法，而封装让你无需知道对象的构造就能使用它。
- 属性是归属于对象的变量，就像方法一样。
- 在较旧的 Python 版本中，类型和类之间泾渭分明：内置对象是基于类型的，而自定义对象是基于类的。因此，你可以创建类，但不能创建类型。在较新的 Python 2 版本中，这种差别不那么明显。在 Python 3 中，已不再区分类和类型了。
旧式类和新式类是有差别的。现在实在没有理由再使用旧式类了，但在 Python 3 之前，默认创建的是旧式类。在较旧的 Python 版本中，要创建新式类，应在脚本或模块开头放置赋值语句__metaclass__ = type，但我不会在每个示例中都显式地包含这条语句。当然，还有其他解决方案，如从新式类（如object）派生出子类。
```py
__metaclass__ = type        # 如果你使用的是Python 2，请包含这行代码
```
- 可将属性定义为私有。私有属性不能从对象外部访问，而只能通过存取器方法（如get_name和set_name）来访问
- 要让方法或属性成为私有的（不能从外部访问），只需让其名称以两个下划线打头即可。
- 如果你不希望名称被修改，又想发出不要从外部修改属性或方法的信号，可用一个下划线打头。这虽然只是一种约定，但也有些作用。例如，`from module import *`不会导入以一个下划线打头的名称。从某种程度上说，以一个和两个下划线打头相当于两种不同的私有程度。
- 使用多重继承时，有一点务必注意：如果多个超类以不同的方式实现了同一个方法（即有多个同名方法），必须在class语句中小心排列这些超类，因为位于前面的类的方法将覆盖位于后面的类的方法。多个超类的超类相同时，查找特定方法或属性时访问超类的顺序称为方法解析顺序（MRO），它使用的算法非常复杂。所幸其效果很好，你可能根本无需担心。
- 抽象基类
Python 通过引入模块abc提供了官方解决方案。这个模块为所谓的抽象基类提供了支持。一般而言，抽象类是不能（至少是不应该）实例化的类，其职责是定义子类应实现的一组抽象方法。下面是一个简单的示例：
```py
from abc import ABC, abstractmethod

class Talker(ABC):
    @abstractmethod
    def talk(self):
        pass
```
这里的要点是你使用@abstractmethod来将方法标记为抽象的——在子类中必须实现的方法。
抽象类（即包含抽象方法的类）最重要的特征是不能实例化。

> 面向对象程序设计:
1. 将相关的东西放在一起。如果一个函数操作一个全局变量，最好将它们作为一个类的属性和方法。
2. 不要让对象之间过于亲密。方法应只关心其所属实例的属性，对于其他实例的状态，让它们自己去管理就好了。
3. 慎用继承，尤其是多重继承。继承有时很有用，但在有些情况下可能带来不必要的复杂性。要正确地使用多重继承很难，要排除其中的 bug 更难。
4. 保持简单。让方法短小紧凑。一般而言，应确保大多数方法都能在 30 秒内读完并理解。对于其余的方法，尽可能将其篇幅控制在一页或一屏内。

确定需要哪些类以及这些类应包含哪些方法时，尝试像下面这样做。

(1) 将有关问题的描述（程序需要做什么）记录下来，并给所有的名词、动词和形容词加上标记。

(2) 在名词中找出可能的类。

(3) 在动词中找出可能的方法。

(4) 在形容词中找出可能的属性。

(5) 将找出的方法和属性分配给各个类。


抽象基类：使用模块abc可创建抽象基类。抽象基类用于指定子类必须提供哪些功能，却不实现这些功能。

